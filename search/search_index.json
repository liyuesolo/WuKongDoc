{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#wukong-simulation","title":"WuKong Simulation","text":"<p>WuKong is an extremely light-weight and modular simulation codebase for different type of discretizations commonly used in computer graphics.</p>"},{"location":"#why-wukong","title":"Why WuKong","text":"<p>The computer graphics community is incredible and champions open-source development. Many projects showcased at Siggraph can be reproduced by those new to graphics. However, for a beginner\u2014or someone from a different field who just wants to see a wobbly sphere moving on the screen\u2014a full-fledged Siggraph codebase might be overkill. In fact, it often requires significant effort to strip away all the advanced features to achieve a basic implementation.</p> <p>WuKong offers a solution by providing minimal code for simulating some of the most fundamental models in graphics. Another common challenge is compilation. Many codebases are designed to simulate a wide range of phenomena, meaning you may need to compile all the relevant libraries. Although a proper CMake setup can simplify this process, integrating such simulations into another project, like in reinforcement learning, benefits from having fewer dependencies. With this goal in mind, each project in WuKong is self-contained. To compile a single project, you don\u2019t have to compile everything else, and you can simply extract the subfolder without worrying about breaking dependencies.</p>"},{"location":"#wukong-projects","title":"WuKong Projects","text":"<p>WuKong support simulation of </p> <p>Discrete Elastic Shell.</p> <p>Discrete Elastic Rods.</p> <p>Linear Tetrahedral Finite Elements.</p> <p>Quadratic Tetrahedral Finite Elements.</p> <p>Differentiable Geodesic Distance.</p> <p>Eulerian-on-Lagrangian Rods.</p>"},{"location":"#how-to-compile","title":"How to Compile","text":"<p>We provide a docker image for you to run our code on an arbirary Linux machine. Please check out the Docker section to see how to set it up.</p>"},{"location":"#simulation-basics","title":"Simulation Basics","text":"<p>WuKong implements optimization-based Newton solver with backtracking line search. To reduce the learning curve of adapting different simulation projects. All projects follow identical pipeline with major functions with the same names. You can find more information in Newton's Method and Time Stepping</p>"},{"location":"#create-your-project","title":"Create YOUR Project","text":"<p>We prepare a simple script to generate a new project in the Project folder that runs with a viewer. Please refer to New Project to learn more.</p> <p>Author: Yue Li</p> <p>If WuKong contributes to an academic publication, cite it as:</p> <pre><code>@misc{wukong,\n  title = {WuKong},\n  author = {Yue Li and others},\n  note = {https://github.com/liyuesolo/Wukong2024},\n  year = {2024}\n}\n</code></pre> <p>Development of this software was funded in part by the European Research Council (ERC) under the European Union\u2019s Horizon 2020 research and innovation program (grant agreement No. 866480), and the Swiss National Science Foundation through SNF project grant 200021_200644. Our implementation benefits from discussion and references from Juan Montes, Simon D\u00fcnser and Jonas Zehder.</p>"},{"location":"basics/Newtons-method/","title":"Newtons method","text":"<p>We use Newton's method for simulation. All projects contains the following functions which are used for minimizing simulation objective using Newton's method.</p> <pre><code>    // compute total energy\n    T computeTotalEnergy();\n\n    // compute system residual i.e. the negative gradient of the total energy\n    T computeResidual(VectorXT&amp; residual);\n\n    // compute the second derivative of the total energy\n    void buildSystemMatrix(StiffnessMatrix&amp; K);\n\n    // Newton step with line search\n    T lineSearchNewton(const VectorXT&amp; residual);\n\n    // solve a linear system of equations Kdu = f\n    bool linearSolve(StiffnessMatrix&amp; K, const VectorXT&amp; residual,\n                     VectorXT&amp; du);\n</code></pre>"},{"location":"basics/docker/","title":"Docker","text":"<p>Depending on what you need you may choose to build the specific project by changing the CMakeLists.txt in the Project folder</p> <p>Ideally basic simulation models such as, -DiscreteShell, FEM2D/3D, EoLRods- should have only the basic implementation such that they can be inherited whenever needed. </p>"},{"location":"basics/docker/#instructions-for-windows","title":"Instructions for Windows","text":"<p>Install WSL2 from Powershell or Command Prompt:</p> <p>$ wsl --install</p> <p>From the WSL terminal, clone the repository:</p> <p>$ git clone https://github.com/liyuesolo/Wukong2024 --recurse-submodules</p> <p>Navigate to the repository folder:</p> <p>$ cd Wukong2024</p> <p>Open in VSCode:</p> <p>$ code .</p> <p>Rename .devcontiner/devcontainer_windows.json to .devcontainer/devcontainer.json, replacing the existing one. Follow the instructions for Run Docker in VSCode.</p> <p>Give WSL access to the internet for building the docker image. Run the following to open a file editor and replace the existing IP address with 8.8.8.8</p> <p>$ sudo nano /etc/resolv.conf</p>"},{"location":"basics/docker/#docker","title":"Docker","text":"<p>Download the docker image. Change tag \"linux\" if needed.</p> <p>$ docker pull wukongsim/wukong:linux</p> <p>If you wish to build the docker image from scratch from the Dockerfile (not recommended) or rebuild after modifying the dockerfile, run the following in the command line from the directory Wukong2024/.devcontainer.</p> <p>$ docker build -t wukongsim/wukong:linux .</p> <p>If finished modifying the Dockerfile, push to dockerhub.</p> <p>$ docker push wukongsim/wukong:linux</p>"},{"location":"basics/docker/#install-nvidia-docker","title":"Install NVIDIA Docker","text":"<p>$ curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg</p> <p>$ curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \\     sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' | \\     sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list</p> <p>$ sudo sed -i -e '/experimental/ s/^#//g' /etc/apt/sources.list.d/nvidia-container-toolkit.list</p> <p>$ sudo apt-get update</p> <p>$ sudo apt-get install -y nvidia-container-toolkit</p> <p>$ sudo nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml</p> <p>$ sudo nvidia-ctk runtime configure --runtime=docker</p> <p>$ sudo systemctl restart docker</p>"},{"location":"basics/docker/#enable-display","title":"Enable Display","text":"<p>Enable Docker to connect to host display to spawn GUI windows. Run from command line on host machine, repeat in case of display error.</p> <p>$ xhost +</p>"},{"location":"basics/docker/#run-docker-in-vscode","title":"Run Docker in VSCode","text":"<p>Open the repository folder in VSCode. Install Docker and Dev Containers extensions in VSCode.</p> <p>In VSCode, type <code>control + p</code>, then type <code>&gt;Reopen in Container</code> (with the '&gt;'). This option will show up in the &gt;&lt; tab in the bottom left corner of vscode.</p> <p>The above command will open a dev container using the docker image we provided.</p> <p>There you go! </p>"},{"location":"basics/docker/#run-docker-from-command-line","title":"Run Docker from Command Line","text":"<p>Navigate to repository home directory.</p> <p>$ cd Wukong2024</p> <p>Open the Docker container. \\ <code>-v ./:/{directory-name-in-container}</code> maps current working directory (.) to /{directory-name-in-container} in the Docker container. \\ <code>--network=host -e DISPLAY=$DISPLAY --privileged</code> enables use of host display to spawn GUI windows.</p> <p>$ docker run -v ./:/{directory-name-in-container} -it --network=host -e DISPLAY=$DISPLAY --privileged --rm wukongsim/wukong:linux bash</p> <p>Build the code.</p> <p>$ cd {directory-name-in-container}</p> <p>$ ./build.sh</p>"},{"location":"basics/docker/#docker-image-building-time","title":"Docker Image Building Time","text":"<p>Building this docker image can take a while, for downloading MKL libraries and compiling SuiteSparse from the source code (just to remove a single print).  In case you have a powerful workstation, considering changing all the <code>make -j8</code> to <code>make -j128</code>.</p>"},{"location":"basics/new-project/","title":"New project","text":"<p>WuKong provides a python script to create a empty project with a simulation base class and an application base class. The same script will also create a cmake file and attach the current project to the list of projects. You should be able to compile and run this project without any issue using the provided docker container.</p> <p>To create an empty project, go the Project folder and run</p> <p>$  python create_new_project.py YOUR_PROJECT_NAME</p>"},{"location":"basics/time-stepping/","title":"Time stepping","text":"<p>We use variational implicit Euler for dynamic time stepping and solve for end-of-time-step position \\(\\mathbf{x}_t\\) $$  E_{\\mathrm{total}} = E_{\\mathrm{inertia}} + E_{\\mathrm{elastic}} + E_{\\mathrm{external}} + E_{\\mathrm{contact}} \\ ,  $$ where the inertial energy is computed as $$ E_{\\mathrm{inertia}} = \\frac{1}{2} (x_t - 2_{t-1} + x_{t-2})^{T} \\mathbf{M} (x_t - 2x_{t-1} + x_{t-2}) \\ . $$</p> <p>The energy corresponding to constant external forces \\(\\mathbf{f}\\) is simply \\(E_{\\mathrm{external}} = \\mathbf{f}^{T} \\mathbf{x}_t \\ .\\)</p> <p>The formula for elastic energy can be found in the projects.</p> <p>We use the contact potential from IPC.</p>"},{"location":"basics/type-def/","title":"Type def","text":"<p>For legacy reasons, WuKong uses the following type defs</p> <pre><code>    template &lt;typename T, int dim&gt;\n    using Vector = Eigen::Matrix&lt;T, dim, 1, 0, dim, 1&gt;;\n\n    template &lt;typename T, int n, int m&gt;\n    using Matrix = Eigen::Matrix&lt;T, n, m, 0, n, m&gt;;\n\n\n    using T = double;\n\n    using VectorXT = Matrix&lt;T, Eigen::Dynamic, 1&gt;;\n    using MatrixXT = Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt;;\n    using VectorXi = Vector&lt;int, Eigen::Dynamic&gt;;\n    using MatrixXi = Matrix&lt;int, Eigen::Dynamic, Eigen::Dynamic&gt;;\n    using TV = Vector&lt;T, 3&gt;;\n    using TV2 = Vector&lt;T, 2&gt;;\n    using TM2 = Matrix&lt;T, 2, 2&gt;;\n    using TV3 = Vector&lt;T, 3&gt;;\n    using IV = Vector&lt;int, 3&gt;;\n    using IV2 = Vector&lt;int, 2&gt;;\n    using TM = Matrix&lt;T, 3, 3&gt;;\n    using StiffnessMatrix = Eigen::SparseMatrix&lt;T&gt;;\n    using Entry = Eigen::Triplet&lt;T&gt;;\n</code></pre>"},{"location":"projects/discrete-elastic-rods/","title":"Discrete elastic rods","text":"<p>To allow for sparse energy Hessian, we adopt the time-parallel transport strategy proposed by Bergou et al., where for each rod segment, in addition to the twist angle, we further track a reference twist with respect to the reference frame.</p> <p>The stretching energy is fairly straightforward and can be computed as \\begin{equation} E_{\\mathrm{stretch}} = \\frac{1}{2} k_s \\sum_{i=0}^{N}\\frac{1}{L_i}(l_i - L_i)^2 \\end{equation}</p> <p>To compute the bending and twisting energy for two adjacent segments, \\begin{equation} E_{\\mathrm{bend}} = \\frac{1}{2} \\sum_{i=1}^{N} \\frac{1}{L_{vi}} (\\boldsymbol{\\kappa}_i - \\tilde{\\boldsymbol{\\kappa}}_i)^{T} \\mathbf{B} (\\boldsymbol{\\kappa} - \\tilde{\\boldsymbol{\\kappa}}_i) \\ , \\end{equation} where \\(\\boldsymbol{\\kappa}\\) is the material curvature and \\(\\mathbf{b}\\) is a constant diagonal stiffness matrix. Here, \\(L_{vi}\\) is the Voronoi edge length computed from the two adjacent edges, i.e. \\(L_{vi} = \\frac{1}{2}(|\\mathbf{x}_i - \\mathbf{x}_j| + |\\mathbf{x}_i - \\mathbf{x}_k|)\\)</p> <p>To compute \\(\\boldsymbol{\\kappa}\\), we first compute the curvature binormal from the two tangent vectors of the two adjacent edges for vertex \\(i\\) following $\\kappa\\mathbf{b}i = \\frac{2\\mathbf{t}{i1} \\times \\mathbf{t}{i2}}{1 + \\mathbf{t}{i1} \\cdot \\mathbf{t}_{i2}} \\ .</p> <p>We then compute the discrete material curvature using curvature binormal and the adapted frames following</p> \\[\\begin{equation}     \\boldsymbol{\\kappa}_i = [\\kappa \\mathbf{b}_i \\cdot \\frac{ \\mathbf{b}_{i1} + \\mathbf{b}_{i2}}{2}, \\kappa \\mathbf{b}_i \\cdot \\frac{ \\mathbf{n}_{i1} + \\mathbf{n}_{i2}}{2}]^{T} \\ , \\end{equation}\\] <p>where \\(\\mathbf{b}\\) and \\(\\mathbf{n}\\) are the normal and binormal vectors of the adapted frame. The adapted frames are computed using parallel transport. \\begin{equation}     E_{\\mathrm{twsit}}  =  \\frac{1}{2} k_t \\sum_{i=1}^{N} \\frac{1}{L_i}(m_i - \\tilde{m}_i)^2 \\end{equation}</p> <p>The twist for a given vertex \\(i\\) can be computed as \\begin{equation}     m_i  = \\theta_{i2} - \\theta_{i1} + \\bar{m_i} + \\theta_i \\ , \\end{equation} where \\(\\theta_{i1}\\) and \\(\\theta_{i2}\\) are the rest angle for the two segments connected to vertex \\(i\\). Furthermore, \\(\\bar{m_i}\\) and \\(\\theta_i\\) are the reference twist and the change of the reference twist.</p>"},{"location":"projects/discrete-elastic-shells/","title":"Discrete elastic shells","text":""},{"location":"projects/discrete-elastic-shells/#elastic-energies","title":"Elastic Energies","text":"<p>To simulate discrete elastic shells, we use the StVK model for in-plane tension and compression, along with a hinge-based bending energy suitable for both planar and non-planar rest shapes. Below, we provide the formulas used in our implementation.</p> <p>In-plane energy $$ E_{\\mathrm{stretching}} = k_s A ((1 - \\mu) ||\\mathbf{E}||_2 +  \\mu \\  \\text{tr}(\\mathbf{E})^2) \\ , $$ where \\(\\mathbf{E}\\) is the Green strain tensor and \\(A\\) is the undeformed triangle area.</p> <p>The in-plane stiffness \\(k_s\\) is computed from the shell thickness \\(h\\), Young's modulus \\(E\\), and Poisson's ratio \\(\\mu\\), as follows: $$ k_s = \\frac{E h}{1.0 - \\mu^2} \\ . $$</p> <p>Bending energy</p> \\[ E_{\\mathrm{bending}} = k_b L (\\theta - \\theta_0)^2 \\ , \\] <p>where \\(L\\) represents the undeformed length of the hinge computed from the area of the parallelograms formed by the two adjacent triangles.</p> <p>The bending stiffness \\(k_b\\) is calculated using: $$ k_b = \\frac{E h^3}{24 (1.0 - \\mu^2)} \\ . $$</p>"},{"location":"projects/discrete-elastic-shells/#gravity","title":"Gravity","text":"<p>The gravitational potential energy per triangle is computed as: $$ E_{\\mathrm{gravity}} = A \\rho h g c_y  $$ where \\(\\rho\\) is the density, \\(g\\) is gravitational acceleration, and \\(c_y\\) is the vertical (\\(y\\)) position of the triangle centroid.</p>"},{"location":"projects/isohedral-tiling/","title":"Isohedral tiling","text":"<p>Isohedral tiling provides a compact parameter space which can be used to generate metamaterials. In this project, we provdie a 2D mesh generator given an arbitrary set of isohedral tiling parameters</p>"},{"location":"projects/linear-tet-fem/","title":"Linear tet fem","text":""},{"location":"projects/linear-tet-fem/#elastic-energy","title":"Elastic Energy","text":"<p>WuKong implements StVK and Neohookean energy models</p> \\[\\begin{equation}     E_{\\mathrm{StVK}} = V \\  \\frac{\\lambda}{2}||\\mathrm{E}||^2 + \\mu \\text{tr}(\\mathbf{E}) \\ , \\end{equation}\\] \\[\\begin{equation}     E_{\\mathrm{NH}} = V \\  \\frac{\\mu}{2}( \\text{tr}(\\mathbf{F}^T)\\mathbf{F} - 3.0 - 2.0 \\log(\\det(\\mathbf{F}))) + \\frac{\\lambda}{2} \\log(\\det(\\mathbf{F}))^2 \\end{equation}\\] <p>where \\(\\mathbf{F}\\) is the deformation gradient, \\(\\mathbf{E}\\) is Green strain, \\(\\lambda\\) and \\(\\mu\\) are Lame parameters, and \\(V\\) is the undeformed volume.</p>"},{"location":"projects/quad-tet-fem/","title":"Quad tet fem","text":"<p>In this example we provide a simple simulation setup with quadratic tetrahedral elements.</p>"},{"location":"projects/quad-tet-fem/#node-index","title":"Node Index","text":""}]}